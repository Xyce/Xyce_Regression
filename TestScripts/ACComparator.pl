#!/usr/bin/env perl

# This comparator handles the comparison of the .FD.prn files generated by .PRINT AC
# statements.  It should be used until xyce_verify.pl is adapted to handle AC analyses 
# properly (which is a much harder task than this one).

# This script takes two file names, a "gold standard" (goodfile) and a file to test
# (testfile) against that gold standard.

# It performs the following checks:

# - First, it compares the contents of the first line, presumed to be the 
#   header.  It checks that the columns present in the gold standard header
#   are also present in the test file.
# - It then reads both files into arrays, and checks that their sizes are
#   appropriate for the selected gsformat.
# - If the format has an Index column then those columns must match exactly 
#   in both files.
# - It then checks each line of the test array and makes sure that its
#   frequency value matches (to within a relative tolerance "$freqreltol") the value
#   in the gold standard on that line.
# - Finally, it performs a point-wise error computation on each other value
#   present on the line, requiring that each quantity in the test file be 
#   within abstol and reltol of the corresponding value in the gold standard.
#   For these comparisions, zerotol is also used.  If both the gold data and
#   the test data are less than zerotol then the comparision is not done.
# 
# - The abstol, reltol, zerotol and freqreltol values are user-specified
#   arguments to ACComparator.  So, the command syntax is:
#
#      ACComparator [options] <goldFileName> <testFileName> abstol reltol zerotol freqreltol

use Getopt::Long;
use Scalar::Util qw(looks_like_number);

# used to print additional debugging information, mainly about
# successful comparisons
sub debugPrint
{
  print @_ if ($debug);
}


###########################
# Process inputs
###########################
# determine the format of the gold standard.  xyceprn is the default.
# also determine any other options
$gsformat="xyceprn";

#Read any options
&GetOptions( "gsformat=s" => \$gsformat,
             "skipfooter" => \$skipfooter,
             "debug!" => \$debug,
             "help!" => \$help );

if ( defined $help )
{
  print "Usage: $0 [options] goodfile testfile absTol relTol zeroTol freqRelTol\n";
  print "options:\n";
  print "--debug       # enables debug output\n";
  print "--help        # print out help info\n";
  print "--gsformat    # goodfile format. Options are: xyceprn, otherprn, xycecsv. Default is xyceprn\n";
  print "--skipfooter  # omits checking footer in testfile\n";
  exit 0;
}

# check that the gold standard format is valid
if ( !( ($gsformat eq "xyceprn") || 
        ($gsformat eq "xycecsv") ||
        ($gsformat eq "otherprn") ) )
{
    print STDERR "gsformat option for ACComparator.pl was $gsformat. Options are: xyceprn, xycecsv or otherprn\n";
    exit 1;
}

# Argument processing.  Don't assume any defaults for absTol, relTol, zeroTol and freqRelTol.
# User must explicitly pass them into the script.
if ($#ARGV != 5)
{
    print STDERR "Invalid number of arguments on command line.\n";
    print STDERR "Usage: $0 [options] goodfile testfile  absTol relTol zeroTol freqRelTol\n";
    exit 1;
}

$goldstandard=$ARGV[0];
$testfile=$ARGV[1];
$abstol=$ARGV[2];
$reltol=$ARGV[3];   
$zerotol=$ARGV[4];
$freqreltol=$ARGV[5];

debugPrint "gsformat,abstol,reltol,zerotol,freqreltol= $gsformat,$abstol,$reltol,$zerotol,$freqreltol\n";


############################################
# open good and test files and read in data
############################################
if (not -s "$goldstandard" ) 
{ 
  print STDERR "Missing goodfile: $goldstandard\nExit code = 2\n"; 
  exit 2;
}
if (not -s "$testfile" ) 
{ 
  print STDERR "Missing testfile: $testfile\nExit code = 14\n";  
  exit 14;
}

open(GSFILEH,$goldstandard);
open(TESTFILEH,$testfile);

@gsdata=ReadDataFile(GSFILEH,\@gsheaderdata);
@testdata=ReadDataFile(TESTFILEH,\@testheaderdata);


############################################
# Set variables based on --gsformat option 
############################################
if ($gsformat eq "xyceprn")
{
    #for --gsformat=xyceprn, the last row will be the simulation footer
    $numdatarows=$#gsdata-1;
    $freqCol=1;
}
elsif ($gsformat eq "xycecsv")
{
    #for --gsformat=xycecsv, there is no simulation footer
    $numdatarows=$#gsdata;
    $freqCol=0;
}
elsif ($gsformat eq "otherprn")
{
    #for --gsformat=otherprn, there is no simulation footer
    $numdatarows=$#gsdata;
    $freqCol=1;
}
else
{
    print STDERR "unknown gsformat of $gsformat for ACComparator.pl\n";
    exit 1;
}
debugPrint "numdatarows = $numdatarows\n";


####################################################################################
# Compare the header lines.  For our purposes, FREQ and "frequency" are equivalent,
# as one is used by Xyce and the other by SPICE.
# First check that the header lines have the same number of fields.
####################################################################################
if ($#gsheaderdata != $#testheaderdata)
{
    print STDERR "Testfile and goodfile have a different # of elements on their header lines.\n";
    print STDERR "Testfile had $#testheaderdata elements. Goodfile had $#gsheaderdata elements.\n";
    print STDERR " Test data:  @testheaderdata\n Good: @gsheaderdata\n";
    exit 2;
}

# Next, compare the string fields on the header line
for ($i=0;$i<=$#gsheaderdata;$i++)
{
    # Allow for FREQ and frequency to be synonyms if the 
    # Gold Standard was not generated by Xyce.
    if ($gsformat eq "otherprn") 
    {
      $gsheaderdata[$i] =~ s/frequency/FREQ/;
    }

    if ($gsheaderdata[$i] ne $testheaderdata[$i])
    {
        print STDERR "Header mismatch on field $i, goodfile has $gsheaderdata[$i], testfile has $testheaderdata[$i]\n";
        exit 2;
    }
}


###############################################################################
# Compare the number of entries in the rows that contain data and (possibly)
# the simulation footer.  They should be the same for xyceprn and xycecsv.
# For otherprn, the goodfile may have fewer rows.
###############################################################################
if ( ($gsformat eq "xyceprn") || ($gsformat eq "xycecsv") )
{
    if ($#gsdata != $#testdata)
    {
        print STDERR "Testfile $#testdata data lines.  Goodfile $#gsdata data lines.\n";
        print STDERR "This is an error if the gsformat for ACComparator.pl is xyceprn or xycecsv\n";
        exit 2;
    }
}
elsif ($gsformat eq "otherprn")
{
    if ($#gsdata > $#testdata)
    {
        print STDERR "Testfile has fewer data lines ($#testdata) then goodfile ($#gsdata) \n";
        print STDERR "This is an error if the gsformat is otherprn\n";
        exit 2;
    }
    elsif ($#testdata > $#gsdata)
    {
        # The test file having more rows is common for this case, since the Xyce-generated 
        # output may have a simulation footer, but a gold standard generated with Spice3f5 
        # won't.  Error out if the "extra rows" in the test file start with a number rather 
        # than a string.
        for ($i=$#gsdata+1;$i<=$#testdata;$i++)
        {
            if (looks_like_number($testdata[$i][$0]))
            {
                print STDERR "Testfile appears to have more data rows than goodfile\n";
                print STDERR "This is an error if the gsformat for ACComparator.pl is otherprn\n";
                exit 2;        
            }
        }
    }
}
else
{
    print STDERR "unknown gsformat option of $gsformat for ACComparator.pl\n";
    exit 1;
}


############################################################################
# Now compare every line's index.  Index values should match exactly.
############################################################################
if ( ($gsformat eq "xyceprn") || ($gsformat eq "otherprn") )
{
  for ($i=0;$i<=$numdatarows;$i++)
  {
    debugPrint "goodfile and testfile Index = $gsdata[$i][0], $testdata[$i][0]\n";
    if ($gsdata[$i][0] != $testdata[$i][0])
    {
        print STDERR "Index mismatch on index $i! Goodfile: $gsdata[$i][0] testfile: $testdata[$i][0]\n";
        exit 2;
    }
  }
}
elsif ($gsformat eq "xycecsv") 
{ 
  # error out if an Index column is found
  if ( ($gsheaderdata[0] eq "Index") || ($testheaderdata[0] eq "Index") )
  {
      print STDERR "Index column found for gsformat=xycecsv\n";
      exit 2;
  }
}
else
{
  print STDERR "unknown gsformat option of $gsformat for ACComparator.pl\n";
  exit 1;
}


######################################################################################
# Now compare every line's frequency.  FREQ values should match to within freqreltol.
######################################################################################
for ($i=0;$i<=$numdatarows;$i++)
{
   debugPrint "goodfile and testfile freq = $gsdata[$i][$freqCol], $testdata[$i][$freqCol]\n";
   if ($gsdata[$i][$freqCol] != $testdata[$i][$freqCol])
   {
        if ($gsdata[$i][$freqCol] != 0)
        {
            $relDiff=abs($testdata[$i][$freqCol]-$gsdata[$i][$freqCol])/$gsdata[$i][$freqCol];
            debugPrint "relDiff = $relDiff\n";
            if ($relDiff > $freqreltol)
            {
                print STDERR "Frequency mismatch on index $i! GS $gsdata[$i][$freqCol] test $testdata[$i][$freqCol]\n";
                print STDERR "Calculated relDiff = $relDiff\n";
                exit 2;
            }
        }
        else
        {
            if ($testdata[$i][$freqCol]>$abstol)
            {
                print STDERR "Frequency mismatch on index $i! GS $gsdata[$i][$freqCol] test $testdata[$i][$freqCol]\n";
                exit 2;
            }
        }
    }
}


#########################################################
# now compare all the other data columns, line-by-line:
#########################################################
for ($i=0;$i<=$numdatarows;$i++)
{
    # error out if the number of fields on a line are different,
    # or if either values is not a number.
    if ( ($#{$gsdata[$i]}) != ($#{$testdata[$i]}) )
    {
        print STDERR "Test and gold files have a different # of elements on line with Index $i.\n";
        exit 2;
    }

    # otherwise, compare the fields on the line
    for ($j=2;$j<=$#{$gsdata[$i]};$j++)
    {
        debugPrint "for i,j=$i,$j gooddata and testdata = $gsdata[$i][$j],$testdata[$i][$j]\n";
        if ($gsdata[$i][$j] != $testdata[$i][$j])
        {
            if ( (abs($gsdata[$i][$j]) < $zerotol) && (abs($testdata[$i][$j]) < $zerotol) )
            {
              # no op since both test and gold data are less than the zero tolerance
	      debugPrint "good $gsdata[$i][$j] and test data $testdata[$i][$j] both less than zeroTol\n";
            }
            else
            {
	        $absDiff = abs($testdata[$i][$j] - $gsdata[$i][$j]);
                $relDiff = $absDiff / abs($gsdata[$i][$j]);   
                if ( ( $absDiff < $abstol ) && ( $relDiff < $reltol ) )
                {
                    # two numeric fields match to within specified absolute and relative tolerances
                    # debug info, to verify that the comparison is working okay
                    debugPrint "Data match. Calculated absDiff and relDiff = ($absDiff,$relDiff)\n";
                }
                else
                {
                    print STDERR "Data mismatch on column $j data line $i! GS $gsdata[$i][$j] test $testdata[$i][$j]\n";
                    print STDERR "Calculated absDiff and relDiff = ($absDiff,$relDiff)\n"; 
                    exit 2;
                }
            }
        }
    }
}

######################################
# now check the simulation footer
######################################
if ($skipfooter)
{
  #no op.  don't check footer line
  print "Skipped check of simulation footer, since --skipfooter specified\n";
}
elsif ($gsformat eq "xyceprn")
{
  # if --gsformat=xyceprn all of these fields should be strings in both files
  for ($j=0;$j<=$#{$gsdata[$#gsdata]};$j++)
  {
     debugPrint "good and test strings are: $gsdata[$#gsdata][$j] and $testdata[$#gsdata][$j]\n";
     if ( (looks_like_number($gsdata[$#gsdata][$j])) || (looks_like_number($testdata[$#gsdata][$j])) )
     {
         print STDERR "Number field in Xyce simulation footer text\n";
         print STDERR "GS $gsdata[$#gsdata][j] test $testdata[$#gsdata][j]\n";
         exit 2;
     }
     elsif ( $gsdata[$#gsdata][$j] ne $testdata[$#gsdata][$j] )
     {
         print STDERR "String mismatch in Xyce simulation footer text\n";
         print STDERR "GS and test strings are: $gsdata[$#gsdata][$j] and $testdata[$#gsdata][$j]\n";
         exit 2;
     }
  } 
}
elsif ( ( $gsformat eq "otherprn" ) || ( $gsformat eq "xycecsv" ) )
{
  # These formats should not have a footer.  So, the last data row should be all numbers 
  # in both files.
  for ($j=0;$j<=$#{$gsdata[$#gsdata]};$j++)
  {
    if ( !(looks_like_number($gsdata[$#gsdata][$j])) || !(looks_like_number($testdata[$#gsdata][$j])) )
    {
        print STDERR "Apparent Xyce simulation footer text for --gsformat=$gsformat\n";
        print STDERR "GS $gsdata[$#gsdata][j] test $testdata[$#gsdata][j]\n";
        exit 2;
    }
  }
}
else
{
    print STDERR "unknown gsformat option of $gsformat for ACComparator.pl\n";
    exit 1;
}


sub ReadDataFile
{
    my ($fileh,$headerref)=@_;

    my $headread,$line;
    my @retarray;

    $headread=0;

    while ($line=<$fileh>)
    {
        chomp($line);
        # Remove all leading spaces, otherwise split adds an extra field.
        $line =~ s/^\s+//;
        if ($headread==0)
        {
            @$headerref=split(/[\s,]+/,$line);
            $headread=1;
        }
        else
        {
            #Remove leading spaces on line, otherwise the spaces become 
            # element 0 of "@retarray" instead of the first column of data.
            $line =~ s/^\s*//;
            push @retarray,[split(/[\s,]+/,$line)];
        }

    }

    return @retarray;
}
