#
# This is the common code used in the XDM regression testing
#

package XdmCommon;
use strict;
use Scalar::Util qw(looks_like_number);
use XyceRegression::Tools;

#
# get Xyce XML Version
#
sub getXyceXMLVersion
{
  my $XYCEXML;

  # hard code XDM locations for now
  #my $PSPICEXML="\$XDMFORMAT/pspice_9_1.xml";
  #my $XYCEXML="\$XDMFORMAT/xyce_6_3.xml";
  #$XYCEXML="xyce_6_4";
  #$XYCEXML="xyce_6_5";
  $XYCEXML="xyce";

  return $XYCEXML;
}

#
# get xdm_wrap version
#
sub getXdmWrapVersion
{
  my $XDMWRAP;

  # the xdm_wrap script sets up (and cleans-up) the environment
  # (e.g., python version) required to run xdm.  The xdm_wrap
  # line should be used to test against the "current released
  # version" of xdm.  The other lines are used to select a particular
  # version of xdm for testing.
  # xdm 1.4.0 is the current released version of xdm.  So, xdm_wrap
  # will point to that version also.
  my $XDMWRAP="xdm_bdl";

  return $XDMWRAP;
}

#
# Used to set up the XDM environment for XDM "translate" mode
# (e.g., translating from PSpice to Xyce or from Spectre to Xyce).
# This includes generating the XDM command line string, the name of
# the "from pspice netlist", the name of the subdirectory where the
# translated Xyce netlist will go, and the file format (e.g., .csd
# or .prn) generated by the translated Xyce netlist.
#
sub setXDMvariables
{
  my ($FROMSPICE,$CIRFILE)=@_;

  # declare some variables
  my $FROMSPICEXML;
  my $XYCEXML;
  my $OUTFILETYPE;

  my $XYCEXML=getXyceXMLVersion();
  my $XDMWRAP=getXdmWrapVersion();
  if ($FROMSPICE eq "pspice")
  {
    $FROMSPICEXML="pspice";
    $OUTFILETYPE="csd";
  }
  elsif ($FROMSPICE eq "spectre")
  {
    $FROMSPICEXML="spectre";
    $OUTFILETYPE="prn";
  }
  elsif ($FROMSPICE eq "hspice")
  {
    $FROMSPICEXML="hspice";
    # $OUTFILETYPE="csd";
    $OUTFILETYPE="prn";
  }
  else
  {
    print "invalid value ($FROMSPICE) for FROMSPICE variable.\n";
    print "Exit code = 2\n";
    exit 2;
  }

  # Other SPICE netlist file name (e.g, PSpice) and name of the directory
  # where the translated files go.
  my $FROMSPICEFILE="$CIRFILE.$FROMSPICE";
  my $TRANSLATEDDIR="$CIRFILE-translated";

  # these are xdm execution strings that will be used later.  The
  # xdm command syntax changed with xdm 1.2.0.  So, the correct string
  # must be chosen, based on the $XDMWRAP variable.
  # run xdm on the gold Other Spice netlist. Use these with xdm_wrap1.0 and xdm_wrap1.1
  #my $CMD="xdm.py $PSPICEFILE $PSPICEXML pspice ./translated $XYCEXML";
  #my $CMD="xdm.py $PSPICEFILE $PSPICEXML ./translated $XYCEXML > $CIRFILE.xdm.out";
  #my $CMD="$XDMWRAP $FROMSPICEFILE $FROMSPICEXML ./$TRANSLATEDDIR $XYCEXML > $CIRFILE.xdm.out";

  # use this with xdm version 1.2.0, or later
  my $XDMEXECSTR="$XDMWRAP -s $FROMSPICEXML -d ./$TRANSLATEDDIR -o $XYCEXML --auto -l DEBUG $FROMSPICEFILE > $CIRFILE.xdm.out";

  # use this with xdm_wrap1.1.1
  #my $XDMEXECSTR="$XDMWRAP $FROMSPICEFILE $FROMSPICEXML ./$TRANSLATEDDIR $XYCEXML > $CIRFILE.xdm.out";

  return ($XDMEXECSTR,$FROMSPICEFILE,$TRANSLATEDDIR,$OUTFILETYPE);
}

#
# used to verify a correct translation, where XDM may emit some warning
# messages to stdout.  There is also the ability to test for strings in
# translated Xyce netlist, but only in the translated.cir file.
#
sub verifyXDMtranslation
{
  my ($XYCE,$XYCE_VERIFY,$CIRFILE,$FROMSPICE,$absTol,$relTol,$zeroTol,$verbose,
           $xdmOutputSearchStringsPtr,$translatedXyceNetlistSearchStringsPtr,$GOLDPRN)=@_;

  my $Tools = XyceRegression::Tools->new();
  #$Tools->setDebug(1);

  # Make the "execution string" that will be used to invoke XDM. Also get the name of
  # the "from SPICE" file, and where to put the xdm-translated files.
  my ($XDMEXECSTR,$FROMSPICEFILE,$TRANSLATEDDIR,$OUTFILETYPE) = setXDMvariables($FROMSPICE,$CIRFILE);

  # script will be used to convert .csd to .prn
  my $TRANSLATESCRIPT = $XYCE_VERIFY;
  my $TRANSLATESCRIPT =~ s/xyce_verify.pl/convertToPrn.py/;

  if (defined($verbose)) { $Tools->setVerbose(1); }

  # Clean up from any previous runs.  The translated subdirectory would
  # be cruft from a previous version of this perl module.
  `rm -f $CIRFILE.csd $CIRFILE.prn $CIRFILE.err $CIRFILE.out`;
  `rm -rf ./translated`;
  `rm -f ./$TRANSLATEDDIR/*.csd ./$TRANSLATEDDIR/*.prn`;
  `rm -f ./$TRANSLATEDDIR/*.err ./$TRANSLATEDDIR/*.out`;

  # run known good Xyce .cir file, and check that it worked
  my $retval = 0;
  if ($OUTFILETYPE eq "prn")
  {
    $retval=system("$XYCE -o $CIRFILE.prn $CIRFILE > $CIRFILE.out 2> $CIRFILE.err");
  }
  else
  {
    $retval=system("$XYCE $CIRFILE > $CIRFILE.out 2> $CIRFILE.err");
  }
  if ($retval != 0)
  {
    print STDERR "Xyce crashed trying to run gold file\n";
    print "Exit code = 14 \n";
    exit 14;
  }
  else
  {
    print "Gold Xyce netlist ran\n";
  }
  # Translations of PSPICE netlists will generate .csd files.
  # Translations of Spectre netlists will generate .prn files.
  # Translations of HSPICE netlists will generate .prn files.
  if (not -s "$CIRFILE.$OUTFILETYPE" )
  {
    print ".$OUTFILETYPE file missing for gold Xyce netlist\n";
    print "Exit code = 14\n";
    exit 14;
  }

  # For translations of HSPICE, comparison of the "gold standard" output and runtime output of gold netlist.
  if (-s $GOLDPRN)
  {
    if ($FROMSPICE eq "hspice")
    {
      $retval = system("$XYCE_VERIFY $CIRFILE $GOLDPRN $CIRFILE.prn > $CIRFILE.gold.out 2> $CIRFILE.gold.err");
    }
    # check retval from Gold vs. runtime output comparison
    if ($retval != 0)
    {
      print "comparison of gold and runtime .$OUTFILETYPE files failed\n";
      print "Exit code = $retval\n";
      exit $retval;
    }
    else
    {
      print ".$OUTFILETYPE gold comparison succeeded\n";
    }
  }

  # run xdm
  my $CMD=$XDMEXECSTR;

  if (system($CMD) != 0)
  {
    print "XDM exited with errors, or failed to run\n";
    print "Exit code = 2\n";
    exit 2;
  }
  else
  {
    print "XDM translation succeeded\n";
  }

  # rename the translated file
  $CMD="mv ./$TRANSLATEDDIR/$FROMSPICEFILE ./$TRANSLATEDDIR/$CIRFILE";
  if (system($CMD) != 0)
  {
    print "Rename of translated file failed.\n";
    print "Exit code = 2\n";
    exit 2;
  }

  # run the translated netlist and check for errors.
  # need to change directories to ./translated so that the translated .lib and .NET files
  # are used.
  chdir "./$TRANSLATEDDIR";
  if ($OUTFILETYPE eq "prn")
  {
    $retval=system("$XYCE -o $CIRFILE.prn $CIRFILE > $CIRFILE.out 2> $CIRFILE.err");
  }
  elsif ($OUTFILETYPE eq "csd")
  {
    $retval=system("$XYCE $CIRFILE > $CIRFILE.out 2> $CIRFILE.err");
  }
  if ($retval != 0)
  {
    print STDERR "Xyce crashed trying to run translated files\n";
    print "Exit code = 14 \n";
    exit 14;
  }
  else
  {
    print "Translated Xyce netlist ran\n";
  }
  # Translations of PSPICE netlists will generate .csd files.
  # Translations of Spectre netlists will generate .prn files.
  # Translations of HSPICE netlists will generate .prn files.
  if (not -s "$CIRFILE.$OUTFILETYPE" )
  {
    print ".$OUTFILETYPE file for translated Xyce netlist missing\n";
    print "Exit code = 14\n";
    exit 14;
  }

  # change back to the top-level directory for the comparison
  chdir "..";

  # now compare the output from the "gold" and translated netlists.
  # Translations of PSPICE netlists will generate .csd files.
  # Translations of Spectre netlists will generate .prn files.
  # Translations of HSPICE netlists will generate .prn files.
  if ($FROMSPICE eq "pspice")
  {
    $retval = XdmCommon::compareCSDfiles("$CIRFILE.csd","./$TRANSLATEDDIR/$CIRFILE.csd",$absTol,$relTol,$zeroTol);
  }
  elsif ($FROMSPICE eq "spectre")
  {
    # use xyce_verify since Spectre tests make .prn files.
    # Use the translated netlist as the "good file", so that comp() statements
    # can be in the "gold" netlist.
    $retval = system("$XYCE_VERIFY $CIRFILE ./$TRANSLATEDDIR/$CIRFILE.prn $CIRFILE.prn > $CIRFILE.out 2> $CIRFILE.err");
  }
  elsif ($FROMSPICE eq "hspice")
  {
    $retval = system("$XYCE_VERIFY $CIRFILE ./$TRANSLATEDDIR/$CIRFILE.prn $CIRFILE.prn > $CIRFILE.out 2> $CIRFILE.err");
  }
  else
  {
   # should not ever get here, but just in case ...
   print "invalid value ($FROMSPICE) for FROMSPICE variable.\n";
   print "Exit code = 2\n";
   exit 2;
  }
  # check retval from Gold vs. Translated output comparison
  if ($retval != 0)
  {
    print "comparison of gold and translated .$OUTFILETYPE files failed\n";
    print "Exit code = $retval\n";
    exit $retval;
  }
  else
  {
    print ".$OUTFILETYPE file comparison succeeded\n";
  }

  # now check for any xdm warning messages in the .stdout file
  if (defined $xdmOutputSearchStringsPtr)
  {
    print "checking for xdm warning/error messages\n";
    my @xdmOutputSearchStrings = @$xdmOutputSearchStringsPtr;
    $retval = $Tools->checkError("$CIRFILE.xdm.out",@xdmOutputSearchStrings);
    if ($retval != 0)
    {
      print "search for xdm warning/error messages failed\n";
      print "Exit code = $retval\n";
      exit $retval;
    }
    else
    {
      print "test for xdm warning/error messages passed\n";
    }
  }

  if (defined $translatedXyceNetlistSearchStringsPtr)
  {
    chdir "./$TRANSLATEDDIR";
    print "checking for strings in translated Xyce netlist\n";
    my @translatedXyceNetlistSearchStrings = @$translatedXyceNetlistSearchStringsPtr;
    $retval = $Tools->checkError("$CIRFILE",@translatedXyceNetlistSearchStrings);
    if ($retval != 0)
    {
      print "search for string in translated Xyce netlist failed\n";
      print "Exit code = $retval\n";
      exit $retval;
    }
    else
    {
      print "test for string in translated Xyce netlist passed\n";
      chdir "..";
    }
  }

  print "Exit code = $retval\n"; exit $retval;
}

#
# Used for case where XDM produces a fatal error during translation
#
#
# used to verify a correct translation, where XDM may emit some warning
# messages to stdout
#
sub runAndCheckXDMerror
{
  my ($XYCE,$XYCE_VERIFY,$CIRFILE,$FROMSPICE,$verbose,$searchStringsPtr)=@_;

  my $Tools = XyceRegression::Tools->new();
  #$Tools->setDebug(1);

  # Make the "execution string" that will be used to invoke XDM. Also get the name of
  # the "from SPICE" file, and where to put the xdm-translated files.
  my ($XDMEXECSTR,$FROMSPICEFILE,$TRANSLATEDDIR) = setXDMvariables($FROMSPICE,$CIRFILE);

  # script will be used to convert .csd to .prn
  my $TRANSLATESCRIPT = $XYCE_VERIFY;
  my $TRANSLATESCRIPT =~ s/xyce_verify.pl/convertToPrn.py/;

  if (defined($verbose)) { $Tools->setVerbose(1); }

  my $CMD=$XDMEXECSTR;

  if (system($CMD) == 0)
  {
    print "XDM should have exited with an error\n";
    print "Exit code = 2\n";
    exit 2;
  }

  # remove the translated subdirectory since it's not going to be used
  `rm -r ./$TRANSLATEDDIR/`;

  # check the xdm error messages in the .stdout file
  my $retval = 0;

  if (defined $searchStringsPtr)
  {
    print "checking for xdm error messages\n";
    my @searchstrings = @$searchStringsPtr;
    $retval = $Tools->checkError("$CIRFILE.xdm.out",@searchstrings);
    if ($retval != 0)
    {
      print "search for xdm error messages failed\n";
    }
    else
    {
      print "test for xdm error messages passed\n";

    }
  }
  else
  {
    print "test failed because no search strings defined\n";
    $retval=2;
  }

  print "Exit code = $retval\n";
  exit $retval;
}

#
# used to verify error/warning messages generated by the
# translated Xyce netlist.  The Xyce output is not verified
# against a "gold" Xyce netlist.
#
sub translateAndCheckXyceMessages
{
  my ($XYCE,$XYCE_VERIFY,$CIRFILE,$FROMSPICE,$verbose,
           $warnError,$translatedXyceNetlistSearchStringsPtr,$xdmOutputSearchStringsPtr)=@_;

  my $Tools = XyceRegression::Tools->new();
  my $retval = 0;
  #$Tools->setDebug(1);

  # Make the "execution string" that will be used to invoke XDM. Also get the name of
  # the "from SPICE" file, and where to put the xdm-translated files.
  my ($XDMEXECSTR,$FROMSPICEFILE,$TRANSLATEDDIR,$OUTFILETYPE) = setXDMvariables($FROMSPICE,$CIRFILE);

  if (defined($verbose)) { $Tools->setVerbose(1); }

  # Clean up from any previous runs.  The translated subdirectory would
  # be cruft from a previous version of this perl module.
  `rm -rf ./translated`;
  `rm -f ./$TRANSLATEDDIR/*.csd ./$TRANSLATEDDIR/*.prn`;
  `rm -f ./$TRANSLATEDDIR/*.err ./$TRANSLATEDDIR/*.out`;

    # run xdm
  my $CMD=$XDMEXECSTR;

  if (system($CMD) != 0)
  {
    print "XDM exited with errors, or failed to run\n";
    print "Exit code = 2\n";
    exit 2;
  }
  else
  {
    print "XDM translation succeeded\n";
  }

  if (defined $xdmOutputSearchStringsPtr)
  {
    print "checking for xdm warning/error messages\n";
    my @xdmOutputSearchStrings = @$xdmOutputSearchStringsPtr;
    $retval = $Tools->checkError("$CIRFILE.xdm.out",@xdmOutputSearchStrings);
    if ($retval != 0)
    {
      print "search for xdm warning/error messages failed\n";
      print "Exit code = $retval\n";
      exit $retval;
    }
    else
    {
      print "test for xdm warning/error messages passed\n";
    }
  }

  # rename the translated file
  $CMD="mv ./$TRANSLATEDDIR/$FROMSPICEFILE ./$TRANSLATEDDIR/$CIRFILE";
  if (system($CMD) != 0)
  {
    print "Rename of translated file failed.\n";
    print "Exit code = 2\n";
    exit 2;
  }

  # run the translated netlist and check for Xyce netlist errors or warnings.
  # need to change directories to ./translated so that the translated .lib and .NET files
  # are used.
  chdir "./$TRANSLATEDDIR";
  if ($FROMSPICE eq "hspice")
  {
    $retval=system("$XYCE $CIRFILE -o $CIRFILE.prn > $CIRFILE.out 2> $CIRFILE.err");
  }
  else
  {
    $retval=system("$XYCE $CIRFILE > $CIRFILE.out 2> $CIRFILE.err");
  }

  if ($warnError eq "WARNING")
  {
    # For warnings, the translated Xyce netlist should run but produce
    # warning messages.
    if ($retval != 0)
    {
      print STDERR "Xyce crashed trying to run translated files\n";
      print "Exit code = 14 \n";
      exit 14;
    }
    else
    {
      print "Translated Xyce netlist ran\n";
    }

    # Translations of PSPICE netlists will generate .csd files.
    # Translations of Spectre netlists will generate .prn files.
    if (not -s "$CIRFILE.$OUTFILETYPE" )
    {
      print ".$OUTFILETYPE file for translated Xyce netlist missing\n";
      print "Exit code = 14\n";
      exit 14;
    }
  }
  elsif ($warnError eq "ERROR")
  {
    # handle ERROR case, translated Xyce netlist should not run
    if ($retval == 0)
    {
      print STDERR "Translated Xyce netlist should not have run\n";
      print "Exit code = 2 \n";
      exit 2;
    }
  }
  else
  {
    print STDERR "translateAndCheckXyceMessages() subroutine requires ERROR or WARNING\n";
    print "Exit code = 2 \n";
    exit 2;
  }

  print "checking for Xyce warning/error messages in translated netlist\n";
  my @searchstrings = @$translatedXyceNetlistSearchStringsPtr;
  $retval = $Tools->checkError("$CIRFILE.out",@searchstrings);
  print "Exit code = $retval\n"; exit $retval;
}

#
# Used to compare .csd files
#
sub compareCSDfiles
{
  my ($goldFileName,$testFileName,$absTol,$relTol,$zeroTol)=@_;

  my $exitCode=0;
  my $testFileCount=0;
  my $gsCount=0;
  my $absDiff=0;
  my $relDiff=0;
  my $i=0;
  my $idx=0;
  my @gsData;
  my @goldData;
  my @testFileData;
  my @testData;

  # open files and check that the files have the same number of lines
  if (not -s "$goldFileName" )
  {
    print STDERR "Missing Gold Standard file: $goldFileName\nExit code = 2\n";
    $exitCode=2;
    print "test Failed!\n";
    print "Exit code = $exitCode\n";
    exit $exitCode;
  }
  if (not -s "$testFileName" )
  {
    print STDERR "Missing Test file: $testFileName\nExit code = 14\n";
    $exitCode=14;
    print "test Failed!\n";
    print "Exit code = $exitCode\n";
    exit $exitCode;
  }

  open(TESTFILE,"$testFileName");
  open(GSFILE,"$goldFileName");

  # first test if the files have the same number of lines
  for (my $testFileCount=0; <TESTFILE>; $testFileCount++) { }
  for (my $gsCount=0; <GSFILE>; $gsCount++) { }

  close(GSFILE);
  close(TESTFILE);

  $exitCode=0;
  if ($testFileCount != $gsCount)
  {
    print STDERR "file $testFileName doesn't match the Gold Standard\n";
    print STDERR "$testFileName line count= $testFileCount\n";
    print STDERR "Gold Standard line count= $gsCount\n";
    $exitCode=2;
  }
  else
  {
    # If the line counts match, then compare in detail.
    # Re-open the files and compare them line by line.
    open(TESTFILE,"$testFileName");
    open(GSFILE,"$goldFileName");
    my $lineCount=0;
    my $lineGS;
    my $lineTestFile;
    my @gsData;
    my @goldData;
    my @testFileData;
    my @testData;
    my $foundDataStart=0;
    while( ($lineGS=<GSFILE>) && ($lineTestFile=<TESTFILE>) )
    {
      $lineCount++;
      # process a line into text and values.
      chop $lineGS;
      # Remove leading spaces on lineGS, otherwise the spaces become
      # element 0 of "@gsData" instead of the first column of data.
      $lineGS =~ s/^\s*//;
      @gsData = (split(/[\s,]+/, $lineGS));

      # process a line into text and values.
      chop $lineTestFile;
      # Remove leading spaces on line, otherwise the spaces become
      # element 0 of "testFileData" instead of the first column of data.
      $lineTestFile =~ s/^\s*//;
      @testFileData = (split(/[\s,]+/, $lineTestFile));

      if ($lineTestFile =~ /#C/)
      {
        $foundDataStart=1;
      }

      if ($#gsData != $#testFileData)
      {
        print STDERR "File $testFileName and Gold Standard have a different # of elements on line $lineCount:\n";
        print STDERR "File $testFileName had $#testFileData elements\n";
        print STDERR "Gold Standard had $#gsData elements\n";
        $exitCode=2;
      }
      # skip version and date/time lines, since they may change in each
      # test run.  Also need to handle XBEGIN line separately.  Also skip
      # title line for now since it has the file name, which differs
      elsif ( ($lineTestFile =~ /SOURCE/) || ($lineTestFile =~ /TIME/) || ($lineTestFile =~ /TITLE/))
      {
        #no op
      }
      else
      {
        # the two files have the same number of items on a line.
        # compare individual values as scalars or strings
        for( $i=0; $i<=$#testFileData; $i++ )
        {
          if ( ($testFileData[$i] =~ /XBEGIN/) || ($testFileData[$i] =~ /XEND/) )
          {
            # XBEGIN line has numbers formatted as XBEGIN='0.00000000e+00' XEND='1.00000000e-02'
            # Need to extract the numbers.
            @testData = split(/[\']/,$testFileData[$i]);
            @goldData = split(/[\']/,$gsData[$i]);

            if ($#gsData != $#testFileData)
            {
              print STDERR "File $testFileName and Gold Standard have mismatched XBEGIN line\n";
              $exitCode=2;
              last;
            }
            if( ($testData[0] eq $goldData[0]) )
            {
              # two string fields match for XBEGIN and XEND
            }
            else
            {
              print STDERR "String elements failed compare on line $lineCount:\n";
              print STDERR "File $testFileName produced: \"$testFileData[$i]\" \n";
              print STDERR "Gold Standard was: \"$gsData[$i]\" \n";
              $exitCode=2;
              last;
            }
            if ( ( abs($testData[1]) <= $zeroTol ) && ( abs($goldData[1]) <= $zeroTol ) )
	    {
              # no op since both test and gold data are less than the zero tolerance
	    }
            else
            {
	      $absDiff = abs($testData[1] - $goldData[1]);
              $relDiff = $absDiff / abs($goldData[1]);
              if ( ( $absDiff < $absTol ) && ( $relDiff < $relTol ) )
              {
                # two numeric fields match to within specified absolute tolerance and relative tolerance
              }
              else
              {
                print STDERR "Numeric comparison failed in column $i on line $lineCount: \n";
                print STDERR "File $testFileName had \"$testFileData[$i]\" while Gold Standard had \"$gsData[$i]\" \n";
                print STDERR "Calculated absDiff and relDiff = ($absDiff,$relDiff)\n";
                $exitCode=2;
                last;
              }
            }
          }
          else
          {
            # this handles date elements from lines that don't start with XBEGIN.
            # There are three cases, as noted in the comments below.
	    if ( ($foundDataStart > 0) && ($testFileData[$i] =~ /:/ ) && ($gsData[$i] =~/:/) )
            {
              # these are fields that contain time points.  They are of the form  0.0001:1
              # where 0.0001 is the value and 1 is the idx.  This next block breaks them
              # apart into two pieces, each of which is tested separately.  These values are
              # found after the #C line
              @testData = split(/:/,$testFileData[$i]);
              @goldData = split(/:/,$gsData[$i]);
              foreach $idx (0 .. 1)
              {
                if ( ( abs($testData[$idx]) <= $zeroTol ) && ( abs($goldData[$idx]) <= $zeroTol ) )
	        {
                  # no op since both test and gold data are less than the zero tolerance
	        }
                else
                {
	          $absDiff = abs($testData[$idx] - $goldData[$idx]);
                  if (abs($goldData[$idx]) > 0)
		  {
                    $relDiff = $absDiff / abs($goldData[$idx]);
                  }
                  else
                  {
                    $relDiff = 0;
                  }

		  if ( ( $absDiff < $absTol ) && ( $relDiff < $relTol ) )
                  {
                    # two numeric fields match to within specified absolute tolerance and relative tolerance
                  }
                  else
                  {
                    print STDERR "Numeric comparison failed in column $i on line $lineCount: \n";
                    print STDERR "File $testFileName had \"$testFileData[$i]\" while Gold Standard had \"$gsData[$i]\" \n";
                    print STDERR "Calculated absDiff and relDiff = ($absDiff,$relDiff)\n";
                    $exitCode=2;
                    last;
                  }
		}
                if ($exitCode != 0) { last;}
              }
            }
            elsif ( looks_like_number($testFileData[$i]) && looks_like_number($gsData[$i]) )
            {
              # this block is for numbers that didn't match the value:idx format above
	      if ( ( abs($testFileData[$i]) <= $zeroTol ) && ( abs($gsData[$i]) <= $zeroTol ) )
	      {
                # no op since both test and gold data are less than the zero tolerance
	      }
              else
              {
	        $absDiff = abs($testFileData[$i] - $gsData[$i]);
                if (abs($gsData[$i]) > 0)
		{
                  $relDiff = $absDiff / abs($gsData[$i]);
                }
                else
                {
                  $relDiff = 0;
                }
                if ( ( $absDiff < $absTol ) && ( $relDiff < $relTol ) )
                {
                  # two numeric fields match to within specified absolute tolerance and relative tolerance
                  # debug info, to verify that the comparison is working okay
                  #print STDERR "Numeric comparison for column $i on line $lineCount: \n";
                  #print STDERR "File $testFileName had \"$testFileData[$i]\" while Gold Standard had \"$gsData[$i]\" \n";
                  #print STDERR "Calculated absDiff and relDiff = ($absDiff,$relDiff)\n";
                }
                else
                {
                  print STDERR "Numeric comparison failed in column $i on line $lineCount: \n";
                  print STDERR "File $testFileName had \"$testFileData[$i]\" while Gold Standard had \"$gsData[$i]\" \n";
                  print STDERR "Calculated absDiff and relDiff = ($absDiff,$relDiff)\n";
                  $exitCode=2;
                  last;
                }
              }
            }
            elsif( ($testFileData[$i] eq $gsData[$i]) )
            {
              # two string fields match
              # debug info to verify that the string comparison is working okay
              #print STDERR "$testFileData[$i] same as $gsData[$i]\n";
            }
            else
            {
              print STDERR "String elements failed compare on line $lineCount:\n";
              print STDERR "File $testFileName produced: \"$testFileData[$i]\" \n";
              print STDERR "Gold Standard was: \"$gsData[$i]\" \n";
              $exitCode=2;
              last;
            }
          }
        }
      }
    }

    # close files
    close(GSFILE);
    close(TESTFILE);
  }

  return $exitCode;
}

#
# We need the 1; at the end because, when Perl loads a module, Perl checks
# to see that the module returns a true value to ensure it loaded OK.
#
1;

#
# End of common code used in each XDM test
#
